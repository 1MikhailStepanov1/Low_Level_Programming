// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "request_schema.hxx"

// constant_t
// 

const constant_t::type_type& constant_t::
type () const
{
  return this->type_.get ();
}

constant_t::type_type& constant_t::
type ()
{
  return this->type_.get ();
}

void constant_t::
type (const type_type& x)
{
  this->type_.set (x);
}

void constant_t::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}

const constant_t::value_type& constant_t::
value () const
{
  return this->value_.get ();
}

constant_t::value_type& constant_t::
value ()
{
  return this->value_.get ();
}

void constant_t::
value (const value_type& x)
{
  this->value_.set (x);
}

void constant_t::
value (::std::unique_ptr< value_type > x)
{
  this->value_.set (std::move (x));
}


// logical_condition_t
// 

const logical_condition_t::logical_operation_type& logical_condition_t::
logical_operation () const
{
  return this->logical_operation_.get ();
}

logical_condition_t::logical_operation_type& logical_condition_t::
logical_operation ()
{
  return this->logical_operation_.get ();
}

void logical_condition_t::
logical_operation (const logical_operation_type& x)
{
  this->logical_operation_.set (x);
}

void logical_condition_t::
logical_operation (::std::unique_ptr< logical_operation_type > x)
{
  this->logical_operation_.set (std::move (x));
}

const logical_condition_t::field_sequence& logical_condition_t::
field () const
{
  return this->field_;
}

logical_condition_t::field_sequence& logical_condition_t::
field ()
{
  return this->field_;
}

void logical_condition_t::
field (const field_sequence& s)
{
  this->field_ = s;
}

const logical_condition_t::condition_optional& logical_condition_t::
condition () const
{
  return this->condition_;
}

logical_condition_t::condition_optional& logical_condition_t::
condition ()
{
  return this->condition_;
}

void logical_condition_t::
condition (const condition_type& x)
{
  this->condition_.set (x);
}

void logical_condition_t::
condition (const condition_optional& x)
{
  this->condition_ = x;
}

void logical_condition_t::
condition (::std::unique_ptr< condition_type > x)
{
  this->condition_.set (std::move (x));
}


// argument_t
// 

const argument_t::field_sequence& argument_t::
field () const
{
  return this->field_;
}

argument_t::field_sequence& argument_t::
field ()
{
  return this->field_;
}

void argument_t::
field (const field_sequence& s)
{
  this->field_ = s;
}

const argument_t::logic_op_sequence& argument_t::
logic_op () const
{
  return this->logic_op_;
}

argument_t::logic_op_sequence& argument_t::
logic_op ()
{
  return this->logic_op_;
}

void argument_t::
logic_op (const logic_op_sequence& s)
{
  this->logic_op_ = s;
}


// object_t
// 

const object_t::obj_name_type& object_t::
obj_name () const
{
  return this->obj_name_.get ();
}

object_t::obj_name_type& object_t::
obj_name ()
{
  return this->obj_name_.get ();
}

void object_t::
obj_name (const obj_name_type& x)
{
  this->obj_name_.set (x);
}

void object_t::
obj_name (::std::unique_ptr< obj_name_type > x)
{
  this->obj_name_.set (std::move (x));
}

const object_t::field_sequence& object_t::
field () const
{
  return this->field_;
}

object_t::field_sequence& object_t::
field ()
{
  return this->field_;
}

void object_t::
field (const field_sequence& s)
{
  this->field_ = s;
}

const object_t::relation_sequence& object_t::
relation () const
{
  return this->relation_;
}

object_t::relation_sequence& object_t::
relation ()
{
  return this->relation_;
}

void object_t::
relation (const relation_sequence& s)
{
  this->relation_ = s;
}


// sub_operation_t
// 

const sub_operation_t::sub_op_type_type& sub_operation_t::
sub_op_type () const
{
  return this->sub_op_type_.get ();
}

sub_operation_t::sub_op_type_type& sub_operation_t::
sub_op_type ()
{
  return this->sub_op_type_.get ();
}

void sub_operation_t::
sub_op_type (const sub_op_type_type& x)
{
  this->sub_op_type_.set (x);
}

void sub_operation_t::
sub_op_type (::std::unique_ptr< sub_op_type_type > x)
{
  this->sub_op_type_.set (std::move (x));
}

const sub_operation_t::field_type& sub_operation_t::
field () const
{
  return this->field_.get ();
}

sub_operation_t::field_type& sub_operation_t::
field ()
{
  return this->field_.get ();
}

void sub_operation_t::
field (const field_type& x)
{
  this->field_.set (x);
}

void sub_operation_t::
field (::std::unique_ptr< field_type > x)
{
  this->field_.set (std::move (x));
}


// selection_set_t
// 

const selection_set_t::argument_sequence& selection_set_t::
argument () const
{
  return this->argument_;
}

selection_set_t::argument_sequence& selection_set_t::
argument ()
{
  return this->argument_;
}

void selection_set_t::
argument (const argument_sequence& s)
{
  this->argument_ = s;
}

const selection_set_t::object_sequence& selection_set_t::
object () const
{
  return this->object_;
}

selection_set_t::object_sequence& selection_set_t::
object ()
{
  return this->object_;
}

void selection_set_t::
object (const object_sequence& s)
{
  this->object_ = s;
}

const selection_set_t::sub_operations_sequence& selection_set_t::
sub_operations () const
{
  return this->sub_operations_;
}

selection_set_t::sub_operations_sequence& selection_set_t::
sub_operations ()
{
  return this->sub_operations_;
}

void selection_set_t::
sub_operations (const sub_operations_sequence& s)
{
  this->sub_operations_ = s;
}


// result_set_t
// 

const result_set_t::field_sequence& result_set_t::
field () const
{
  return this->field_;
}

result_set_t::field_sequence& result_set_t::
field ()
{
  return this->field_;
}

void result_set_t::
field (const field_sequence& s)
{
  this->field_ = s;
}


// request_t
// 

const request_t::query_type_type& request_t::
query_type () const
{
  return this->query_type_.get ();
}

request_t::query_type_type& request_t::
query_type ()
{
  return this->query_type_.get ();
}

void request_t::
query_type (const query_type_type& x)
{
  this->query_type_.set (x);
}

void request_t::
query_type (::std::unique_ptr< query_type_type > x)
{
  this->query_type_.set (std::move (x));
}

const request_t::class_type_type& request_t::
class_type () const
{
  return this->class_type_.get ();
}

request_t::class_type_type& request_t::
class_type ()
{
  return this->class_type_.get ();
}

void request_t::
class_type (const class_type_type& x)
{
  this->class_type_.set (x);
}

void request_t::
class_type (::std::unique_ptr< class_type_type > x)
{
  this->class_type_.set (std::move (x));
}

const request_t::selection_set_optional& request_t::
selection_set () const
{
  return this->selection_set_;
}

request_t::selection_set_optional& request_t::
selection_set ()
{
  return this->selection_set_;
}

void request_t::
selection_set (const selection_set_type& x)
{
  this->selection_set_.set (x);
}

void request_t::
selection_set (const selection_set_optional& x)
{
  this->selection_set_ = x;
}

void request_t::
selection_set (::std::unique_ptr< selection_set_type > x)
{
  this->selection_set_.set (std::move (x));
}

const request_t::result_set_optional& request_t::
result_set () const
{
  return this->result_set_;
}

request_t::result_set_optional& request_t::
result_set ()
{
  return this->result_set_;
}

void request_t::
result_set (const result_set_type& x)
{
  this->result_set_.set (x);
}

void request_t::
result_set (const result_set_optional& x)
{
  this->result_set_ = x;
}

void request_t::
result_set (::std::unique_ptr< result_set_type > x)
{
  this->result_set_.set (std::move (x));
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// constant_t
//

constant_t::
constant_t (const type_type& type,
            const value_type& value)
: ::xml_schema::type (),
  type_ (type, this),
  value_ (value, this)
{
}

constant_t::
constant_t (const constant_t& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  type_ (x.type_, f, this),
  value_ (x.value_, f, this)
{
}

constant_t::
constant_t (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  type_ (this),
  value_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void constant_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // type
    //
    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< type_type > r (
        type_traits::create (i, f, this));

      if (!type_.present ())
      {
        this->type_.set (::std::move (r));
        continue;
      }
    }

    // value
    //
    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< value_type > r (
        value_traits::create (i, f, this));

      if (!value_.present ())
      {
        this->value_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "type",
      "");
  }

  if (!value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "value",
      "");
  }
}

constant_t* constant_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class constant_t (*this, f, c);
}

constant_t& constant_t::
operator= (const constant_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->type_ = x.type_;
    this->value_ = x.value_;
  }

  return *this;
}

constant_t::
~constant_t ()
{
}

// logical_condition_t
//

logical_condition_t::
logical_condition_t (const logical_operation_type& logical_operation)
: ::xml_schema::type (),
  logical_operation_ (logical_operation, this),
  field_ (this),
  condition_ (this)
{
}

logical_condition_t::
logical_condition_t (const logical_condition_t& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  logical_operation_ (x.logical_operation_, f, this),
  field_ (x.field_, f, this),
  condition_ (x.condition_, f, this)
{
}

logical_condition_t::
logical_condition_t (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  logical_operation_ (this),
  field_ (this),
  condition_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void logical_condition_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // logical_operation
    //
    if (n.name () == "logical_operation" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< logical_operation_type > r (
        logical_operation_traits::create (i, f, this));

      if (!logical_operation_.present ())
      {
        this->logical_operation_.set (::std::move (r));
        continue;
      }
    }

    // field
    //
    if (n.name () == "field" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< field_type > r (
        field_traits::create (i, f, this));

      this->field_.push_back (::std::move (r));
      continue;
    }

    // condition
    //
    if (n.name () == "condition" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< condition_type > r (
        condition_traits::create (i, f, this));

      if (!this->condition_)
      {
        this->condition_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!logical_operation_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "logical_operation",
      "");
  }
}

logical_condition_t* logical_condition_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class logical_condition_t (*this, f, c);
}

logical_condition_t& logical_condition_t::
operator= (const logical_condition_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->logical_operation_ = x.logical_operation_;
    this->field_ = x.field_;
    this->condition_ = x.condition_;
  }

  return *this;
}

logical_condition_t::
~logical_condition_t ()
{
}

// argument_t
//

argument_t::
argument_t ()
: ::xml_schema::type (),
  field_ (this),
  logic_op_ (this)
{
}

argument_t::
argument_t (const argument_t& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  field_ (x.field_, f, this),
  logic_op_ (x.logic_op_, f, this)
{
}

argument_t::
argument_t (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  field_ (this),
  logic_op_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void argument_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // field
    //
    if (n.name () == "field" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< field_type > r (
        field_traits::create (i, f, this));

      this->field_.push_back (::std::move (r));
      continue;
    }

    // logic_op
    //
    if (n.name () == "logic_op" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< logic_op_type > r (
        logic_op_traits::create (i, f, this));

      this->logic_op_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

argument_t* argument_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class argument_t (*this, f, c);
}

argument_t& argument_t::
operator= (const argument_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->field_ = x.field_;
    this->logic_op_ = x.logic_op_;
  }

  return *this;
}

argument_t::
~argument_t ()
{
}

// object_t
//

object_t::
object_t (const obj_name_type& obj_name)
: ::xml_schema::type (),
  obj_name_ (obj_name, this),
  field_ (this),
  relation_ (this)
{
}

object_t::
object_t (const object_t& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  obj_name_ (x.obj_name_, f, this),
  field_ (x.field_, f, this),
  relation_ (x.relation_, f, this)
{
}

object_t::
object_t (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  obj_name_ (this),
  field_ (this),
  relation_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void object_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // obj_name
    //
    if (n.name () == "obj_name" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< obj_name_type > r (
        obj_name_traits::create (i, f, this));

      if (!obj_name_.present ())
      {
        this->obj_name_.set (::std::move (r));
        continue;
      }
    }

    // field
    //
    if (n.name () == "field" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< field_type > r (
        field_traits::create (i, f, this));

      this->field_.push_back (::std::move (r));
      continue;
    }

    // relation
    //
    if (n.name () == "relation" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< relation_type > r (
        relation_traits::create (i, f, this));

      this->relation_.push_back (::std::move (r));
      continue;
    }

    break;
  }

  if (!obj_name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "obj_name",
      "");
  }
}

object_t* object_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class object_t (*this, f, c);
}

object_t& object_t::
operator= (const object_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->obj_name_ = x.obj_name_;
    this->field_ = x.field_;
    this->relation_ = x.relation_;
  }

  return *this;
}

object_t::
~object_t ()
{
}

// sub_operation_t
//

sub_operation_t::
sub_operation_t (const sub_op_type_type& sub_op_type,
                 const field_type& field)
: ::xml_schema::type (),
  sub_op_type_ (sub_op_type, this),
  field_ (field, this)
{
}

sub_operation_t::
sub_operation_t (const sub_op_type_type& sub_op_type,
                 ::std::unique_ptr< field_type > field)
: ::xml_schema::type (),
  sub_op_type_ (sub_op_type, this),
  field_ (std::move (field), this)
{
}

sub_operation_t::
sub_operation_t (const sub_operation_t& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  sub_op_type_ (x.sub_op_type_, f, this),
  field_ (x.field_, f, this)
{
}

sub_operation_t::
sub_operation_t (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  sub_op_type_ (this),
  field_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void sub_operation_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // sub_op_type
    //
    if (n.name () == "sub_op_type" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< sub_op_type_type > r (
        sub_op_type_traits::create (i, f, this));

      if (!sub_op_type_.present ())
      {
        this->sub_op_type_.set (::std::move (r));
        continue;
      }
    }

    // field
    //
    if (n.name () == "field" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< field_type > r (
        field_traits::create (i, f, this));

      if (!field_.present ())
      {
        this->field_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!sub_op_type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "sub_op_type",
      "");
  }

  if (!field_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "field",
      "");
  }
}

sub_operation_t* sub_operation_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class sub_operation_t (*this, f, c);
}

sub_operation_t& sub_operation_t::
operator= (const sub_operation_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->sub_op_type_ = x.sub_op_type_;
    this->field_ = x.field_;
  }

  return *this;
}

sub_operation_t::
~sub_operation_t ()
{
}

// selection_set_t
//

selection_set_t::
selection_set_t ()
: ::xml_schema::type (),
  argument_ (this),
  object_ (this),
  sub_operations_ (this)
{
}

selection_set_t::
selection_set_t (const selection_set_t& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  argument_ (x.argument_, f, this),
  object_ (x.object_, f, this),
  sub_operations_ (x.sub_operations_, f, this)
{
}

selection_set_t::
selection_set_t (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  argument_ (this),
  object_ (this),
  sub_operations_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void selection_set_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // argument
    //
    if (n.name () == "argument" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< argument_type > r (
        argument_traits::create (i, f, this));

      this->argument_.push_back (::std::move (r));
      continue;
    }

    // object
    //
    if (n.name () == "object" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< object_type > r (
        object_traits::create (i, f, this));

      this->object_.push_back (::std::move (r));
      continue;
    }

    // sub_operations
    //
    if (n.name () == "sub_operations" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< sub_operations_type > r (
        sub_operations_traits::create (i, f, this));

      this->sub_operations_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

selection_set_t* selection_set_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class selection_set_t (*this, f, c);
}

selection_set_t& selection_set_t::
operator= (const selection_set_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->argument_ = x.argument_;
    this->object_ = x.object_;
    this->sub_operations_ = x.sub_operations_;
  }

  return *this;
}

selection_set_t::
~selection_set_t ()
{
}

// result_set_t
//

result_set_t::
result_set_t ()
: ::xml_schema::type (),
  field_ (this)
{
}

result_set_t::
result_set_t (const result_set_t& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  field_ (x.field_, f, this)
{
}

result_set_t::
result_set_t (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  field_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void result_set_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // field
    //
    if (n.name () == "field" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< field_type > r (
        field_traits::create (i, f, this));

      this->field_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

result_set_t* result_set_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class result_set_t (*this, f, c);
}

result_set_t& result_set_t::
operator= (const result_set_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->field_ = x.field_;
  }

  return *this;
}

result_set_t::
~result_set_t ()
{
}

// request_t
//

request_t::
request_t (const query_type_type& query_type,
           const class_type_type& class_type)
: ::xml_schema::type (),
  query_type_ (query_type, this),
  class_type_ (class_type, this),
  selection_set_ (this),
  result_set_ (this)
{
}

request_t::
request_t (const request_t& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  query_type_ (x.query_type_, f, this),
  class_type_ (x.class_type_, f, this),
  selection_set_ (x.selection_set_, f, this),
  result_set_ (x.result_set_, f, this)
{
}

request_t::
request_t (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  query_type_ (this),
  class_type_ (this),
  selection_set_ (this),
  result_set_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void request_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // query_type
    //
    if (n.name () == "query_type" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< query_type_type > r (
        query_type_traits::create (i, f, this));

      if (!query_type_.present ())
      {
        this->query_type_.set (::std::move (r));
        continue;
      }
    }

    // class_type
    //
    if (n.name () == "class_type" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< class_type_type > r (
        class_type_traits::create (i, f, this));

      if (!class_type_.present ())
      {
        this->class_type_.set (::std::move (r));
        continue;
      }
    }

    // selection_set
    //
    if (n.name () == "selection_set" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< selection_set_type > r (
        selection_set_traits::create (i, f, this));

      if (!this->selection_set_)
      {
        this->selection_set_.set (::std::move (r));
        continue;
      }
    }

    // result_set
    //
    if (n.name () == "result_set" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< result_set_type > r (
        result_set_traits::create (i, f, this));

      if (!this->result_set_)
      {
        this->result_set_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!query_type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "query_type",
      "");
  }

  if (!class_type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "class_type",
      "");
  }
}

request_t* request_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class request_t (*this, f, c);
}

request_t& request_t::
operator= (const request_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->query_type_ = x.query_type_;
    this->class_type_ = x.class_type_;
    this->selection_set_ = x.selection_set_;
    this->result_set_ = x.result_set_;
  }

  return *this;
}

request_t::
~request_t ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::unique_ptr< ::request_t >
request (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::request_t > (
    ::request (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::request_t >
request (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::request_t > (
    ::request (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::request_t >
request (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::request_t > (
    ::request (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::request_t >
request (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::request (isrc, f, p);
}

::std::unique_ptr< ::request_t >
request (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::request (isrc, h, f, p);
}

::std::unique_ptr< ::request_t >
request (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::request (isrc, h, f, p);
}

::std::unique_ptr< ::request_t >
request (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::request (isrc, f, p);
}

::std::unique_ptr< ::request_t >
request (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::request (isrc, h, f, p);
}

::std::unique_ptr< ::request_t >
request (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::request (isrc, h, f, p);
}

::std::unique_ptr< ::request_t >
request (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::request_t > (
    ::request (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::request_t >
request (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::request_t > (
    ::request (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::request_t >
request (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::request_t > (
    ::request (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::request_t >
request (const ::xercesc::DOMDocument& doc,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::request_t > (
      ::request (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "request" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::request_t > r (
      ::xsd::cxx::tree::traits< ::request_t, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "request",
    "");
}

::std::unique_ptr< ::request_t >
request (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "request" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::request_t > r (
      ::xsd::cxx::tree::traits< ::request_t, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "request",
    "");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void
operator<< (::xercesc::DOMElement& e, const constant_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // type
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "type",
        e));

    s << i.type ();
  }

  // value
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "value",
        e));

    s << i.value ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const logical_condition_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // logical_operation
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "logical_operation",
        e));

    s << i.logical_operation ();
  }

  // field
  //
  for (logical_condition_t::field_const_iterator
       b (i.field ().begin ()), n (i.field ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "field",
        e));

    s << *b;
  }

  // condition
  //
  if (i.condition ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "condition",
        e));

    s << *i.condition ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const argument_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // field
  //
  for (argument_t::field_const_iterator
       b (i.field ().begin ()), n (i.field ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "field",
        e));

    s << *b;
  }

  // logic_op
  //
  for (argument_t::logic_op_const_iterator
       b (i.logic_op ().begin ()), n (i.logic_op ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "logic_op",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const object_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // obj_name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "obj_name",
        e));

    s << i.obj_name ();
  }

  // field
  //
  for (object_t::field_const_iterator
       b (i.field ().begin ()), n (i.field ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "field",
        e));

    s << *b;
  }

  // relation
  //
  for (object_t::relation_const_iterator
       b (i.relation ().begin ()), n (i.relation ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "relation",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const sub_operation_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // sub_op_type
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "sub_op_type",
        e));

    s << i.sub_op_type ();
  }

  // field
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "field",
        e));

    s << i.field ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const selection_set_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // argument
  //
  for (selection_set_t::argument_const_iterator
       b (i.argument ().begin ()), n (i.argument ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "argument",
        e));

    s << *b;
  }

  // object
  //
  for (selection_set_t::object_const_iterator
       b (i.object ().begin ()), n (i.object ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "object",
        e));

    s << *b;
  }

  // sub_operations
  //
  for (selection_set_t::sub_operations_const_iterator
       b (i.sub_operations ().begin ()), n (i.sub_operations ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "sub_operations",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const result_set_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // field
  //
  for (result_set_t::field_const_iterator
       b (i.field ().begin ()), n (i.field ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "field",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const request_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // query_type
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "query_type",
        e));

    s << i.query_type ();
  }

  // class_type
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "class_type",
        e));

    s << i.class_type ();
  }

  // selection_set
  //
  if (i.selection_set ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "selection_set",
        e));

    s << *i.selection_set ();
  }

  // result_set
  //
  if (i.result_set ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "result_set",
        e));

    s << *i.result_set ();
  }
}

void
request (::std::ostream& o,
         const ::request_t& s,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::request (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
request (::std::ostream& o,
         const ::request_t& s,
         ::xml_schema::error_handler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::request (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
request (::std::ostream& o,
         const ::request_t& s,
         ::xercesc::DOMErrorHandler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::request (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
request (::xercesc::XMLFormatTarget& t,
         const ::request_t& s,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::request (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
request (::xercesc::XMLFormatTarget& t,
         const ::request_t& s,
         ::xml_schema::error_handler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::request (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
request (::xercesc::XMLFormatTarget& t,
         const ::request_t& s,
         ::xercesc::DOMErrorHandler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::request (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
request (::xercesc::DOMDocument& d,
         const ::request_t& s,
         ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "request" &&
      n.namespace_ () == "")
  {
    e << s;
  }
  else
  {
    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "request",
      "");
  }
}

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
request (const ::request_t& s,
         const ::xml_schema::namespace_infomap& m,
         ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::serialize< char > (
      "request",
      "",
      m, f));

  ::request (*d, s, f);
  return d;
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

